classdef testgraphfeatures < matlab.unittest.TestCase
    % TESTGRAPHFEATURES Gremlin steps supported by Azure Cosmos DB for unit testing
    %
    %  STEP     	DESCRIPTION
    % -------------------------------------------------------------------------
    %  drop              Drops the values (vertex/edge)
    %  addE              Adds an edge between two vertices
    %  addV              Adds a vertex to the graph
    %  and               Ensures that all the traversals return a value
    %  has               Used to filter properties, vertices, and edges. Supports hasLabel, hasId, hasNot, and has variants.
    %  as                A step modulator to assign a variable to the output of a step
    %  group             Groups the values based on the labels specified
    %  by                A step modulator used with group and order
    %  coalesce          Returns the first traversal that returns a result
    %  count             Returns the count from the traversal
    %  inject            Inject values into a stream
    %  fold              Acts as a barrier that computes the aggregate of results
    %  limit             Used to limit number of items in the traversal
    %  path              Returns the full path of the traversal
    %  range             Filters to the specified range of values
    %  repeat            Repeats the step for the specified number of times. Used for looping
    %  tree              Aggregate paths from a vertex into a tree
    %  TextP.startingWith(string)       String filtering function. This function is used as a predicate for the has() step to match a property with the beginning of a given string
    %  TextP.endingWith(string)         String filtering function. This function is used as a predicate for the has() step to match a property with the ending of a given string
    %  TextP.containing(string)         String filtering function. This function is used as a predicate for the has() step to match a property with the contents of a given string
    %  TextP.notStartingWith(string)	String filtering function. This function is used as a predicate for the has() step to match a property that doesn't start with a given string
    %  TextP.notEndingWith(string)      String filtering function. This function is used as a predicate for the has() step to match a property that doesn't end with a given string
    %  TextP.notContaining(string)      String filtering function. This function is used as a predicate for the has() step to match a property that doesn't contain a given string
    %  union             Merge results from multiple traversals
    %  V                 Includes the steps necessary for traversals between vertices and edges V, E, out, in, both, outE, inE, bothE, outV, inV, bothV, and otherV
    %  select            Used to project results from the traversal
    %  where             Used to filter results from the traversal. Supports eq, neq, lt, lte, gt, gte, and between operators
    %  is                Used to perform a filter using a boolean expression
    %  order             Returns results in the specified sort order
    %  or                Ensures at least one of the traversals returns a value 
    %  not               Used to produce the negation of a filter
    %
    %
    %  No tests defined yet for the following:
    %  ======================================
    %
    %   STEP             	DESCRIPTION
    %  --------------------------------------------------------------------
    %  dedup             Returns the values with the duplicates removed
    %  constant          Returns a constant value. Used with coalesce
    %  executionProfile	 Creates a description of all operations generated by the executed Gremlin step    
    %  local             Local wraps a section of a traversal, similar to a subquery    
    %  optional          Returns the result of the specified traversal if it yields a result else it returns the calling element      
    %  project           Projects the properties as a Map
    %  properties        Returns the properties for the specified labels
    %  sample            Used to sample results from the traversal
    %  store             Used for non-blocking aggregates from the traversal
    %  unfold            Unroll an iterator as a step
  
    % Ref: https://docs.microsoft.com/bs-latn-ba/azure/cosmos-db/gremlin-support
    %     
    %(Copyright 2020, The MathWorks, Inc.)

    properties
        logObj
        gClient
    end
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Please add your test cases below
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    methods (TestMethodSetup)
        function testSetup(testCase)
            %warning('Initializing Gremlin client within TestMethodSetup');
            % Create client and a test graph
            testCase.gClient = azure.gremlin.GremlinClient();
            testCase.logObj = Logger.getLogger();
            testCase.logObj.MsgPrefix = 'Azure:GREMLIN';
        end
    end
    
    methods (TestMethodTeardown)
        function testTearDown(testCase)
          testCase.gClient.close();
        end
    end
    
    methods (Test)
        function testdrop(testCase)
            write(testCase.logObj,'debug','Dropping any existing graph within Azure Cosmosdb database');
            
            % Drop any existing graph
            queries = "g.V().drop()";
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit({queries});
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing g.V().drop() ');
        end
        function testaddV(testCase)
            % INSERT THE TEST CODE
            write(testCase.logObj,'debug','Adding Vertex to a new graph within Azure Cosmosdb database');
            
            % Create Fresh Airport graph
            
            % Every vertex has a label which is 'airport' here
            vertextype = 'airport';
            
            % Every Vertex has multiple property. In this example we are using properties such as airport 'id', 'year' of
            % construction, 'technology' type used in airport
            property.id = {'AUS', 'DFW', 'LAX', 'JFK', 'ATL'};
            property.pk = 'pkairport';
            property.year = {'1957', '1961', '1948', '1932', '1991'};
            property.tech = {'mech', 'mech', 'auto', 'auto', 'mech'};
            
            % Typically query strings can be created with completely static
            % strings but they are not useful when you need to repeat same
            % queries. In that case to make looping easy we can parametrize
            % the query strings with parameters.
            %
            % In this example we have created the above parameters such as
            % the property struct with key and values for every vertex so
            % that we can repeat the addV() query with respective
            % parameters in a loop for effectively creating graphs
            %
            % Create 5 airport vertices
            % =========================
            % An example static query we are trying to build here is as
            % follows:
            %    "g.addV('airport').property('id','AUS').as('aus').property('year','1957').property('tech','mech').property('pk','pk');
            % The above query needs to be called 5 times for all 5 vertices
            % with their respective property attributes
            %
            % Using strcat and property values to construct query strings
            for i = 1: numel(property.id)
                vertexquerystr{i} = strcat("g.addV('" ,vertextype, "').property('id','", property.id{i} ,"').as('",lower(property.id{i}),"').property('year','", property.year{i} ,"').property('tech','", property.tech{i} ,"').property('pk','" ,property.pk, "')");
            end
            
            % Submit and get resultset post query execution
            resultset = testCase.gClient.submit(vertexquerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing g.addV() ');
        end
        function testaddE(testCase)
            % INSERT THE TEST CODE
            write(testCase.logObj,'debug','Adding edges between vertices of the graph.');
            
            % In this example with vertices representing airports, we are
            % creating edges between two vertices representing routes which
            % will be dirctional in nature. Between two vertices, one of
            % them will act as an out vetex ('outV') and the other as an in
            % vertex or ('inV')
            
            % creating parameters for constructing query strings
            % dynamically
            
            % edge label between vertices is being assigned by a string
            % 'route'
            edgetype = 'route';
            
            % outV defined for egdes
            from = {'aus','atl','atl','dfw','dfw','lax','lax','lax'};
            
            % inV defined for edges
            to = {'atl','dfw','jfk','jfk','lax','jfk','aus','dfw'};
            
            % Create edges/routes between 5 airport vertices
            % ==============================================
            % An example static query we are trying to build here is as
            % follows:
            %    "g.V('AUS').addE('route').to(g.V('ATL'));
            %
            % The above query starts from vertex 'AUS' and adds an outgoing edge of
            % type 'route' which acts as an incoming edge to the vertex
            % 'ATL'
            %
            % The above query needs to be called 8 times for all 8 edges(routes) between vertices
            % to be constructed effectively
            %
            % Using strcat and parameters defined above to construct query strings
            for i = 1: numel(from)
                edgequerystr{i} = strcat("g.V('", upper(from{i}), "').addE('" ,edgetype, "').to(g.V('", upper(to{i}), "'))");
            end
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit( edgequerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing g.V().addE() ');          
        end       
        function testandhas(testCase)
            % INSERT THE TEST CODE            
            write(testCase.logObj,'debug','Testing filtering operations using steps such as "hasLabel", "has" & "and"');
            
            % Constructing query to look for vertices with label 'airport'
            % and property 'tech' as 'auto'
            %
            % 'hasLabel' is used to filter vertices by labels
            % 'and' is used to use two filters together
            % 'has' is used for setting a property based filters
            andquerystr = {"g.V().hasLabel('airport').and().has('tech','auto')"};
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit(andquerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing hasLabel(), and() & has() ');
        end
        function testas(testCase)
            % INSERT THE TEST CODE
            write(testCase.logObj,'debug','Testing as() operation in a query');
            
            % Filtering graph vertices with 'alias' using 'as' rather than
            % 'id'
            filter = 'aus';
            asquerystr = {strcat("g.V().as('",filter,"')")};
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit(asquerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing as() ');
        end
        function testgroupby(testCase)
            % INSERT THE TEST CODE
            write(testCase.logObj,'debug','Testing group() and by() operation in a query');
            
            % 'group' as the name suggests is used for grouping or
            % clustering operation for vertices within a graph
            % 'by' is used along with 'group' to provide a grouping
            % criteria such as similarities  in property attributes
            
            % In this current example we are grouping graph vertices by its
            % property 'tech'. Expecting two clusters to be returned since
            % the property 'tech' in this example holds only two values
            % 'auto' and 'mech'
            byquerystr = {"g.V().group().by('tech')"};
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit(byquerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
                        
            write(testCase.logObj,'debug','Done testing group().by() ');
            
            % Results Description:
            % ===================
            % Expecting 2 groups witin results for 'auto' and 'mech'
            %
            % Each group being a cell arry of length equal to number of airports
            % falling under the bin
            %
            % Each cell array content is of type struct as it will be a vertex in this
            % case with all it's properties
            %
            % results =
            % 
            %   1×1 cell array
            % 
            %     {1×1 cell}
            % 
            % results{1}
            % 
            % ans =
            % 
            %   1×1 cell array
            % 
            %     {1×1 struct}
            % 
            % ans{1}
            % 
            % ans = 
            % 
            %   struct with fields:
            % 
            %     auto: {[1×1 struct]  [1×1 struct]}
            %     mech: {[1×1 struct]  [1×1 struct]  [1×1 struct]}

        end
        function testcolasce(testCase)
            % INSERT THE TEST CODE
            write(testCase.logObj,'debug','Testing colasce() operation in a query');
            
            % The coalesce()-step evaluates the provided traversals in order and returns the first traversal that emits at least one element
            % This query particularly looks for airports and year of
            % manufacturing
            colascequerystr = {"g.V().hasLabel('airport').coalesce(values('id'), values('year'))"};
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit(colascequerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing colasce() ');
        end
        function testcount(testCase)
            % INSERT THE TEST CODE
            write(testCase.logObj,'debug','Testing count() operation in a query');
            
            % The count()-step counts the total number of represented traversers in the streams 
            % In this particular query number of vertices in the graph are
            % expected to be returned
            countquerystr = {"g.V().count()"};
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit(countquerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            % Test for number of vertices 5
            testCase.verifyEqual(response{1}{1},5);
            
            write(testCase.logObj,'debug','Done testing count()');
        end
        function testgroupcount(testCase)
            % INSERT THE TEST CODE
            write(testCase.logObj,'debug','Testing groupCount().by() operation in a query');
            
            % Should return group counts instead of group of vertices
            groupcountquerystr = {"g.V().hasLabel('airport').groupCount().by('tech')"};
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit(groupcountquerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            % Results Description
            % ===================
            % response =
            % 
            %   1×1 cell array
            % 
            %     {1×1 cell}
            % 
            % response{1}
            % 
            % ans =
            % 
            %   1×1 cell array
            % 
            %     {1×1 struct}
            % 
            % ans{1}
            % 
            % ans = 
            % 
            %   struct with fields:
            % 
            %     auto: 2
            %     mech: 3
            write(testCase.logObj,'debug','Done testing groupCount().by()');
        end     
        function testtree(testCase)
            % INSERT THE TEST CODE
            write(testCase.logObj,'debug','Testing groupCount().by() operation in a query');
            
            % Query is designed to traverse 2 vertices out from current
            % vertex and return a tree 
            treequerystr = {"g.V().out().tree()"};
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit(treequerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
        
            % Results Description
            % ===================  
            % response =
            % 
            %   1×1 cell array
            % 
            %     {1×1 cell}
            %             response{1}{1}
            % 
            % ans = 
            % 
            %   struct with fields:
            % 
            %     LAX: [1×1 struct]
            %     ATL: [1×1 struct]
            %     AUS: [1×1 struct]
            %     DFW: [1×1 struct]
            % 
            % lax = ans.LAX
            % 
            % lax = 
            % 
            %   struct with fields:
            % 
            %       key: [1×1 struct]
            %     value: [1×1 struct]
            % 
            % key = lax.key
            % 
            % key = 
            % 
            %   struct with fields:
            % 
            %             id: 'LAX'
            %          label: 'airport'
            %           type: 'vertex'
            %     properties: [1×1 struct]
            % 
            % val = lax.value
            % 
            % val = 
            % 
            %   struct with fields:
            % 
            %     AUS: [1×1 struct]
            %     JFK: [1×1 struct]
            %     DFW: [1×1 struct]
            write(testCase.logObj,'debug','Done testing tree()');
        end    
        function testfold(testCase)
            % INSERT THE TEST CODE
            write(testCase.logObj,'debug','Testing fold() operation in a query');
            % There are situations when the traversal stream needs a "barrier" to aggregate all the objects and emit a computation that is a function of the aggregate. 
            % The fold()-step (map) is one particular instance of this.
            foldquerystr = {"g.V().values('tech').fold()"};
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit(foldquerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing fold()');
        end
        function testlimit(testCase)
            % INSERT THE TEST CODE
            write(testCase.logObj,'debug','Testing limit() operation in a query');
            
            % The limit()-step is analogous to range()-step. save that the lower end range is set to 0
            limitquerystr = {"g.V().limit(2)"};
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit(limitquerystr);
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing limit()');
        end
        function testrange(testCase)
            % INSERT THE TEST CODE
            write(testCase.logObj,'debug','Testing limit() operation in a query');
            
            % As traversers propagate through the traversal, it is possible to only allow a certain number of them to pass through with range()-step (filter). When the low-end of the range is not met, objects are continued to be iterated. When within the low (inclusive) and high (exclusive) range, traversers are emitted. 
            % When above the high range, the traversal breaks out of iteration. 
            % Finally, the use of -1 on the high range will emit remaining traversers after the low range begins.
            rangequerystr = {"g.V().range(0, 2)"};
            
            % Submit and get results post execution
            resultset = testCase.gClient.submit(rangequerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing range()');
        end
        function testrepeatpath(testCase)
            repeatpathquerystr = {"g.V('AUS').repeat(out()).times(2).path().by('id')"};
            % Submit and get results post execution
            resultset = testCase.gClient.submit(repeatpathquerystr);
                        % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing repeat() and path()');
        end
        function testhaswithTextP(testCase)
            hastextPquerystr = {"g.V().has('tech',startingWith('me')).values('id')"};
            % Submit and get results post execution
            resultset = testCase.gClient.submit(hastextPquerystr);
                        % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing haswithTextP');
        end       
        function testunion(testCase)
            unionquerystr = {"g.V('AUS').union(__.in().values('id'),out().values('id'))"};
            % Submit and get results post execution
            resultset = testCase.gClient.submit(unionquerystr);
            
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing union()');
        end       
        function testinject(testCase)
            injectquerystr = {"g.V('AUS').out().values('tech').inject('auto')"};
            % Submit and get results post execution
            resultset = testCase.gClient.submit(injectquerystr);
                       % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing inject()');
        end
        function testselect(testCase)
            selectquerystr = {"g.V().as('AUS').out().as('ATL').out().as('JFK').select('AUS','ATL').by('id')"};
            % Submit and get results post execution
            resultset = testCase.gClient.submit(selectquerystr);
                        % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing select()');
        end
        function testwhereis(testCase)
            % Needs work on query example
            wherequerystr = {"g.V('LAX').out().where('tech',eq('auto'))"};
            % Submit and get results post execution
            resultset = testCase.gClient.submit(wherequerystr);
            % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing where() and is()');
        end
        function testorder(testCase)
            orderquerystr = {"g.V().hasLabel('airport').order().by('id', decr)"};
            % Submit and get results post execution
            resultset = testCase.gClient.submit(orderquerystr);
                       % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing order()');
        end
        function testor(testCase)
            orquerystr = {"g.V().where(outE('route').or().out('id').is(eq('AUS'))).values('id')"};
            % Submit and get results post execution
            resultset = testCase.gClient.submitAsync(orquerystr);
                        % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing or()');
        end        
        function testnot(testCase)
            notquerystr = {"g.V().not(hasLabel('airport').out('tech').is(eq('auto'))).values('id')"};
            % Submit and get results post execution
            resultset = testCase.gClient.submit(notquerystr);
                        % Read and unpack results
            response = resultset.get;
            
            % Test response received
            testCase.verifyNotEmpty(response);
            
            % Test class of response
            testCase.verifyClass(response,'cell');
            
            write(testCase.logObj,'debug','Done testing not()');
        end   
        function closeclient(testCase)
            testCase.gClient.close;
        end
    end
    
end

